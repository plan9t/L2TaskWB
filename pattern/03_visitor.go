package main

import (
	"fmt"
)

/*
	Реализовать паттерн «посетитель».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Visitor_pattern

Посетитель — это поведенческий паттерн, который позволяет добавить новую операцию для целой иерархии классов (структур в го),
не изменяя код этих классов.

Плюсы паттерна "Посетитель":

							1.Разделение обязанностей:
							Посетитель позволяет вынести операции, которые могут изменять или анализировать структуру объектов,
							в отдельные классы. Это способствует разделению обязанностей и делает код более чистым и модульным.

							2.Добавление новых операций:
							Паттерн позволяет легко добавлять новые операции, не изменяя классы элементов.
							Каждый новый посетитель добавляет только ту функциональность, которая ему нужна.

							3.Обход структуры:
							Паттерн "Посетитель" предоставляет механизм для обхода сложных структур объектов,
							что делает его полезным при работе с древовидными или составными структурами.

							4.Открытость/закрытость принцип:
							Посетитель поддерживает принцип "Открытости/закрытости" (Open/Closed Principle),
							так как новые посетители могут быть добавлены, не изменяя код классов элементов.

Минусы паттерна "Посетитель":

							1. Сложность добавления новых классов элементов:
							Если мы часто добавляем новые классы элементов, это может привести к неудобствам,
							так как вам придется обновлять все существующие посетители для поддержки новых классов.

							2. Затруднения в поддержке инкапсуляции:
							Посетитель может нарушить инкапсуляцию элементов, так как он требует открытия интерфейса
							элементов для визиторов. Это может сделать наши классы(структуры в Го) менее защищенными и
							более подверженными изменениям.

							3. Усложнение кода:
							Использование паттерна "Посетитель" может усложнить код и сделать его труднее для понимания,
							особенно если структура объектов и посетителей сложна.

							4. Сопровождение:
							Когда вы изменяете структуру элементов, вам приходится обновлять все посетители,
							что может быть трудоемким и привести к ошибкам.

В примере я использовал фигуры и добавление новых методов для работы с ними через использование посетителей.

P.S: В реализации у меня всё находится в одном пакете согласно структуре. Правильнее было бы разделить логику фигур в отдельные пакеты.

!!!!!P.P.S: В дальнейший заданиях с реализациями паттерном примеры также будут находится в одном пакете и одном файле.
*/

// Описываем интерфейс фигуры.
/*
	В этом интерфейсе определены два метода: getType(), который возвращает тип фигуры, и accept(Visitor), который принимает посетителя.
*/
type Shape interface {
	getType() string
	accept(Visitor)
}

// Описываем квадрат, который реализует интерфейс Shape
type Square struct {
	side int
}

// Метод, который вызывает посетителя для данного типа фигуры (квадрат)
func (s *Square) accept(v Visitor) {
	v.visitForSquare(s)
}

func (s *Square) getType() string {
	return "Square"
}

// Описываем круг. Реализуем интерфейс Shape
type Circle struct {
	radius int
}

// Метод, который вызывает посетителя для данного типа фигуры (круг)
func (c *Circle) accept(v Visitor) {
	v.visitForCircle(c)
}

func (c *Circle) getType() string {
	return "Circle"
}

// Описываем прямоугольник
type Rectangle struct {
	l int
	b int
}

// Метод, который вызывает посетителя для данного типа фигуры (прямоугольник)
func (t *Rectangle) accept(v Visitor) {
	v.visitForRectangle(t)
}

func (t *Rectangle) getType() string {
	return "rectangle"
}

// Описываем интерфейс посетителя. Функции visitForSquare(square), visitForCircle(circle), visitForTriangle(triangle) позволят нам
// добавлять функционал для квадратов, кругов и треугольников соответственно.
// Этот интерфейс определяет методы для каждого типа фигуры, которые будут вызваны при посещении.
// + т.к. нет в Go нет перегрузки, называем методы разными именами.
type Visitor interface {
	visitForSquare(*Square)
	visitForCircle(*Circle)
	visitForRectangle(*Rectangle)
}

// ПЕРВЫЙ ПОСЕТИТЕЛЬ (конкретный доп. метод).
/*
Этот посетитель реализует интерфейс Visitor и предоставляет методы для вычисления площади фигур.
Когда фигура принимает этот посетитель, вызывается соответствующий метод для вычисления площади.
*/
type AreaCalculator struct {
	area int
}

func (a *AreaCalculator) visitForSquare(s *Square) {
	a.area = s.side * s.side
	fmt.Println("Вычисление площади для квадрата: ", a.area)
}

func (a *AreaCalculator) visitForCircle(s *Circle) {
	a.area = 3 * s.radius * s.radius
	fmt.Println("Вычисление площади для круга: ", a.area)
}
func (a *AreaCalculator) visitForRectangle(s *Rectangle) {
	a.area = s.l * s.b
	fmt.Println("Вычисление площади для прямоугольника: ", a.area)
}

// ВТОРОЙ ПОСЕТИТЕЛЬ (ещё один конкретный доп. метод)
// Этот посетитель также реализует интерфейс Visitor, но предоставляет методы для вычисления координат центра фигур.
type MiddleCoordinates struct {
	x int
	y int
}

func (a *MiddleCoordinates) visitForSquare(s *Square) {
	// Тут процесс вычисления средней точки координат
	fmt.Println("Вычисление средней точки координат для квадрата: ", 123)
}

func (a *MiddleCoordinates) visitForCircle(c *Circle) {
	// Тут процесс вычисления средней точки координат
	fmt.Println("Вычисление средней точки координат для круга: ", 123)
}

func (a *MiddleCoordinates) visitForRectangle(t *Rectangle) {
	// Тут процесс вычисления средней точки координат
	fmt.Println("Вычисление средней точки координат для прямоугольника: ", 123)
}

func main() {
	// Создаём объекты фигур
	square := &Square{side: 2}
	circle := &Circle{radius: 3}
	rectangle := &Rectangle{l: 2, b: 3}

	// Создаём посетителя
	areaCalculator := &AreaCalculator{}

	// Каждая фигура принимает посетителя и вызывает соответствующие им методы
	square.accept(areaCalculator)
	circle.accept(areaCalculator)
	rectangle.accept(areaCalculator)

	fmt.Println() // Пустая строка для удобства вывода
	// Создаём ещё посетителя, но для другого метода
	middleCoordinates := &MiddleCoordinates{}

	// Каждая фигура принимает посетителя и вызывает соответствующие им методы
	square.accept(middleCoordinates)
	circle.accept(middleCoordinates)
	rectangle.accept(middleCoordinates)
}
