package main

import (
	"errors"
	"fmt"
	"time"
)

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы,а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern

ФАСАД. Фасад - это структурный паттерн. Фасад представляет простой интерфейс к сложной структуре. Например, когда есть много разных подсистем,
которые реализуют свои интерфейсы и реализуют свой функционал поведения. В решении задания я превёл пример
с интернет-магазином, к которому подключена система оплаты (или обычным магазином, но по безналичной оплате).

МАГАЗИН - свой интерфейс
ПЛАТЁЖНАЯ СИСТЕМА - свой интерфейс

Мы создаём максимально простой интерфейс для покупок, который участвует  в операциях платёжной системы.
Этот интерфейс и будет фасадом НАД поведением платёжной системы.

ПЛЮСЫ: 1. Фасад изолирует клиентов от поведения сложных систем и облегчает его использование, что снижает
	      сложность работы с системой..
       2. Сокращение количества кода, необходимого для выполнения определенных действий.
	   3. Избавление от сложных зависимостей. Зачастую системы имеют сложную структуру,
		  с множеством взаимосвязей между различными компонентами и модулями.
		  Паттерн Facade позволяет скрыть эти зависимости и упрощает работу с ними.
	   4. Обеспечиние модульноси. Использование паттерна Facade позволяет выделить основные
		  функции системы в модулях, которые можно легко заменять, расширять или изменять
		  без воздействия на остальные компоненты.
	   5. Уменьшение риска ошибок. Когда клиенты работают с системой напрямую,
		  это может привести к ошибкам и поломкам. Паттерн Facade позволяет избежать таких проблем,
		  так как ограничивает доступ к внутренней структуре.

МИНУСЫ: 1. Есть вероятность, что фасад может стать "супер-объектом" и все далее создаваемые функции
		   будут проходить через этот "супер-объект".
		2. Ограниченность функционала: Использование паттерна Facade может ограничить клиентов в
		   использовании только тех функций, которые доступны через Фасад.
		3. Нет гибкости в настройке под конкретные требования: Паттерн Facade скрывает внутреннюю
		   реализацию системы, что может ограничить возможность подстройки под конкретные требования клиентов.
		4. Усложнение кода: Использование паттерна Facade может привести к усложнению кода, если
		   не правильно проектировать Фасад.


P.S: В реализации у меня всё находится в одном пакете согласно структуре. Правильнее было бы разделить логику
магазина, банка и пользователя в отдельные пакеты.

*/

// Всё, что относится к магазину
type Product struct {
	Name  string
	Price float64
}

type Shop struct {
	Name     string
	Products []Product
}

// Sell Функция shop.Sell() и будет фасадом. В ней происходят все действия со всеми сервисами:
// самим магазином, банком, его картами, единицами ассортимента и пользователями
// Клиент приходит в магазин, расплачивается картой, при помощи этой карты мы запрашиваем
// иформацию об остатке из банка,и если остаток >0, то мы продаём товар.
// При этом sell() сравнивает баланс на карте со стоимостью товара
func (shop Shop) Sell(user User, product string) error {
	println("[Магазин] Запрос к пользователю для получения остатка баланса на карте")
	time.Sleep(time.Millisecond * 500)
	err := user.Card.CheckBalance()
	if err != nil {
		return err
	}
	fmt.Printf("Может ли пользователь [%s] купить товар? \n", user.Name)
	for _, prod := range shop.Products {
		if prod.Name != product {
			continue
		}
		if prod.Price > user.GetBalance() {
			return errors.New("[Магазин] У пользователя недостаточно средств для покупки товара")
		}
		fmt.Printf("[Магазин] Товар [%s] - куплен!\n", prod.Name)
	}
	return nil
}

// Всё, что относится к платёжной системе
type Card struct {
	Name    string
	Balance float64
	Bank    *Bank
}

func (card Card) CheckBalance() error {
	println("[Карта] Запрос в банк для проверки остатка")
	time.Sleep(time.Millisecond * 500)
	return card.Bank.CheckBalance(card.Name)
}

type Bank struct {
	Name  string
	Cards []Card
}

func (bank Bank) CheckBalance(CardNumber string) error {
	println(fmt.Sprint("[Банк] Получение остатка по карте %s", CardNumber))
	time.Sleep(time.Millisecond * 500)
	for _, card := range bank.Cards {
		if card.Name != CardNumber {
			continue
		}
		if card.Balance <= 0 {
			return errors.New("[Банк] Недостаточно средств!")
		}
	}
	println("[Банк] Остаток положительный!")
	return nil
}

// Всё, что относится к пользователю
type User struct {
	Name string
	Card *Card
}

func (user User) GetBalance() float64 {
	return user.Card.Balance
}

var (
	bank = Bank{
		Name:  "БАНК",
		Cards: []Card{},
	}

	card1 = Card{
		Name:    "1111",
		Balance: 1500,
		Bank:    &bank,
	}

	card2 = Card{
		Name:    "2222",
		Balance: 150,
		Bank:    &bank,
	}

	user = User{
		Name: "Artyom Vdovenko",
		Card: &card1,
	}

	user2 = User{
		Name: "Ne Artyom Vdovenko",
		Card: &card2,
	}

	prod = Product{
		Name:  "Potato",
		Price: 400,
	}

	shop = Shop{
		Name: "Pyatyoro4ka",
		Products: []Product{
			prod,
		},
	}
)

func main() {
	// Поведение выпуска карт банком
	println("[Банк] Выпущено 2 карты")
	bank.Cards = append(bank.Cards, card1, card2)

	// Поведение прожажи пользователю товара\
	fmt.Printf("[%s]", user.Name)
	err := shop.Sell(user, prod.Name)
	if err != nil {
		println(err.Error())
		return
	}

	fmt.Printf("[%s]", user2.Name)
	err = shop.Sell(user2, prod.Name)
	if err != nil {
		println(err.Error())
		return
	}
}
