package main

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern

Паттерн "Фабричный метод" относится к классу порождающих паттернов проектирования и предоставляет интерфейс
для создания объекта в суперклассе, но позволяет подклассам изменять тип создаваемых объектов.

Цель этого паттерна - делегировать ответственность за создание экземпляров классов подклассам,
тем самым позволяя изменять тип создаваемых объектов без изменения кода в суперклассе. Это способствует более гибкой архитектуре,
позволяя легко добавлять новые типы продуктов, расширяя систему.

ПЛЮСЫ:
			1. Расширяемость системы:
			Позволяет легко добавлять новые продукты и соответствующие фабрики, не модифицируя существующий код. Это способствует расширяемости системы.

			2. Отделение создания от использования:
			Клиентский код работает с продуктами через абстрактный интерфейс, что позволяет отделить код, использующий продукты, от кода, создающего продукты.
			Это упрощает поддержку и разработку.

			3. Поддержка принципов SOLID:
			Соблюдение принципов открытости/закрытости (Open/Closed) и инверсии зависимостей (Dependency Inversion),
			так как изменения в подклассах не затрагивают суперкласс.

			4. Повышение гибкости:
			Позволяет адаптировать систему к изменениям в требованиях без больших изменений в коде.


МИНУСЫ:
			1. Сложность:
			Вводит дополнительные классы и интерфейсы, что может привести к увеличению сложности кода. Для простых случаев этот паттерн может показаться избыточным.

			2. Создание большого числа подклассов:
			В случае большого числа продуктов и их фабрик может потребоваться создание множества подклассов, что может быть неудобным в некоторых случаях.

			3. Затруднение в понимании:
			В некоторых случаях может быть затруднительным понимание структуры классов и взаимосвязей между ними, особенно если иерархия продуктов и фабрик сложна.

			4. Потеря контроля:
			Клиентский код не всегда имеет контроль над тем, какой конкретный продукт будет создан. В некоторых ситуациях это может быть нежелательным.

Пример: фабрика для создания различных видов автомобилей.
*/

// Интерфейс для конкретного продукта (автомобиля)
type Car interface {
	Drive() string
}

// Конкретная реализация продукта - седан
type Sedan struct { /*В примере машины без полей, только по методу*/
}

func (s *Sedan) Drive() string {
	return "Вождение на седане"
}

// Конкретная реализация продукта - внедорожник
type SUV struct{}

func (s *SUV) Drive() string {
	return "Вождение на вредорожнике, настоящий off-road"
}

// Фабрика для создания автомобилей
type CarFactory struct{}

// Фабричный метод для создания седана
func (cf *CarFactory) CreateSedan() Car {
	return &Sedan{}
}

// Фабричный метод для создания внедорожника
func (cf *CarFactory) CreateSUV() Car {
	return &SUV{}
}

func main() {
	// Создаем фабрику
	factory := &CarFactory{}

	// Используем фабричные методы для создания седана и внедорожника
	sedan := factory.CreateSedan()
	suv := factory.CreateSUV()

	// Выводим результаты
	fmt.Println(sedan.Drive())
	fmt.Println(suv.Drive())
}
